<!--
 * @Author: error: git config user.name && git config user.email & please set dead value or install git
 * @Date: 2023-01-15 23:34:12
 * @LastEditors: error: git config user.name && git config user.email & please set dead value or install git
 * @LastEditTime: 2023-01-20 20:09:21
 * @FilePath: \CPP\文件操作\职工管理系统.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 利用C++多态实现：职工管理系统
三类员工
- 普通员工：完成经理布置的任务
- 经理：完成老板交给的任务，下发给员工
- 老板：管理公司所有业务

显示信息
- 编号
- 姓名
- 岗位
- 职责

所需要的实现的功能
- 退出管理程序
- 增加职工信息
- 显示职工信息
- 删除离职职工
- 修改职工信息
- 查找职工信息
- 按照编号排序
- 清空所有文档

## 1. 创建管理类
### 内容
- 交互菜单
- 增删查改
- 文件读写交互

## 2. 菜单功能 
```c++
void show_menu();
```
## 3. 退出功能
```c++
void exit_menu(); 
```
## 4. 创建职工类
将三种职工抽象到一个Worker类，利用多态管理不同职工种类

职工属性：编号、姓名、所在部门编号

职工行为：岗位职责信息描述，获取岗位名称
```c++
class Worker
{
public:
    virtual void show_info();
    virtual string get_department_name();

    int m_id;
    string m_name;
    int m_department_id;     
}
class Employee : public Worker
{
/* code */
}
class Manager : public Worker
{
/* code */
}
class Boss : public Worker
{
/* code */
}
```
## 5. 添加职工（增）
功能：批量添加职工，并保存到文件中
### 功能分析
创建的职工类不同

可以将所有员工的指针维护到一个数组里

不定长数组的维护，可以将数组创建到堆区，利用Worker**指针维护
### 功能实现
worker_manager.h中添加成员属性：
```c++
int m_emp_num;
Worker** m_emp_array;
```
Workermanager类构造函数初始化属性
```c++
Workermanager::Workermanager()
{
    this->m_emp_num = 0;
    this->m_emp_array = NULL;
}
```
Workermanager类实现批量添加员工函数
```c++
Workermanager::add_emp()
{
    cout << "num of employee: " << endl; 
    /* code */
}
```
## 6. 写文件
### 功能描述
对文件进行读写。在添加了员工数据之后，一旦程序结束就无法保存，因此需要实现将类保存到文件中。
### 设定文件路径
在workermanager.h中添加路径宏。
```c++
#define FILENAME "empFile.txt"
```
### 成员函数声明
Workermanager类中添加文件保存函数
```c++
void save_file();
```
### 实现方法
遍历worker列表，每次添加worker后，写入文件
```c++
void save_file()
{
    /* code */

    /* 遍历写入*/
    for(int i = 0; i<m_emp_num; i++)
    {
        ofs << m_emp_array[i]->m_id << " "
        << m_emp_array[i]->m_name << " "
        << m_emp_array[i]->m_department_id << endl;
    }
}
```
## 7. 读文件
### 功能描述
每次程序开始时，要将文件中的数据读取到程序中。构造函数分三种情况：
1. 第一次使用，文件未创建
2. 文件存在，但是数据被用户清空
3. 文件存在，并且保存职工的所有数据
### 文件未创建
调用` ifs.is_open() `函数判断文件是否存在,不存在则利用ofs创建新文件
### 存在，但是数据被清空
利用` ifs >> ch `先读一个数据，然后利用` ifs.eof() `方法判断文件是否为空，为空则初始化数据后关闭文件
### 存在，且保存了数据
获取worker数目，然后再初始化成员属性。关键代码:
```c++
while(ifs >> tmp_id && ifs >> tmp_name && ifs >> tmp_department_id)
{
    /* 统计worker数和worker构造 */
    index++;
}
```
## 8. 显示职工
实现展示所有职工信息的功能
```c++
void show_worker_info()
{
    /* code */
}
```
## 9. 删除职工（删）
按照职工的编号进行删除职工操作
### 添加声明
`void del_emp();`
### 职工是否存在
在做删除、修改或者查找时，都需要判断职工是否存在，声明`bool is_emp_exist(int id)`
在删除的时候，实际上可以删除数组某一个元素（这版本没用到……）。示例：
```c++
delete array[index];
```
注意：再删除之后，要进行文件的保存。
## 10. 修改职工（改）
对worker的信息进行修改，为了弥补没用上单个内存释放的遗憾，补上！
```c++
delete this->m_emp_array[index];
```
和删除一样，在修改前都需要判断职工是否存在，然后再进行修改。
```c++
this->m_emp_array[index] = worker;
```
## 11. 查找职工（查）
提供两种查询方式：
1. 编号
2. 姓名
## 12. 排序
按照worker的id进行排序。排序分正序和反序两种。
排序算法，用的最基础的冒泡法。
## 13. 清空文件
清空文本的方法很简单，利用```ios::trunc```的方式打开文本即可。注意，文件删除后，堆区维护的数组也需要清除。```is_File_OK```标志需要清除。
