<!--
 * @Author: error: git config user.name && git config user.email & please set dead value or install git
 * @Date: 2023-01-20 20:58:24
 * @LastEditors: niemike niemike@outlook.com
 * @LastEditTime: 2023-01-21 11:24:39
 * @FilePath: \CPP\模板\笔记.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

# 模板
属于c++提高编程。主要针对c++泛型编程和STL技术进行学习。
## 模板的概念
模板就是建立通用的模具，大大提高复用性。
## 模板的特点
1. 模板不可以直接使用，只是框架
2. 模板的通用并不是万能
## 模板的基本语法
### 函数模板
```c++
template<typename T>
函数声明或定义
```
template：声明创建模板

typename：表明后面的符号是一种数据类型，可以用class代替

T：通用的数据类型，名称可以替换，通常为大写字母

模板使用的时候，有两种方式：
1. 自动推导：```my_swap(a, b);```
2. 显式制定：```my_swap<int>(a, b);```
#### 函数模板的注意事项
1. 自动类型推导，必须推导出 一致的 数据类型T才可以使用
2. 模板必须要确定出T的数据类型，才可以使用

错误1：
```c++
int a;
char b;

my_swap(a, b); //不一致
```
错误2：
```c++
template<class T>
void func()
{
    cout << "fun " << endl;
}

void test()
{
    func(); // 模板没有指定T的数据类型 
    func<int>(); // 可以运行
}
```
#### 普通函数和函数模板的区别
1. 普通函数调用时可以发生自动类型转换
2. 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
3. 如果利用显式指定类型的方式，可以发生隐式类型转换

#### 普通函数和函数模板的调用规则
1. 函数模板可以发生重载
2. 如果函数模板和普通函数都可以实现，优先调用普通函数
3. 可以通过空模板参数列表来强制调用函数模板 
4. 如果函数模板可以产生更好地匹配，优先调用函数模板

#### 模板的局限性
例1：
```c++
template<class T>
void fun(T a, T b)
{
    a = b;
}
// 当传入的a和b是一个数组，就无法实现
```
例2：
```c++
template<class T>
void fun(T a, T b)
{
    if(a>b)
    {

    }
}
//当传入的数据类型是自定义的类型时(如类)，无法操作
```
为解决例2中的问题，需要具体化方式做特殊实现
```c++
class Person
{
public:    
    Person(string name, age)
    {
        this->m_name = name;
        this->m_age = age; 
    }
    string m_name;
    int m_age;
}

template<class T>
bool my_compare(T a, T b)
{
    return (a==b)?true:false;
}

/* 具体化操作 */
template<> bool my_compare(Person &p1, Person &p2)
{
    if(p1.m_name == p2.m_name) 
        return true;
    else 
        return false;
}

void test()
{
    Person p1("a", 12);
    Person p2("b", 13);

    my_compare(p1, p2);
}
```

#### 为什么学习模板
为了在 STL 能够运用系统提供的模板

### 类模板
类模板的作用：
建立通用的类，类中的成员数据类型可以不具体制定

基本使用方法：
```c++
template<class nametype, class agetype>
class Person
{
public:
    Person(nametype name, agetype age)
    {
        this->m_name = name;
        this->m_age = age;
    }
    
    nametype m_name;
    agetype m_age;
};

void test()
{
    Person<string, int> p1("Zhang San", 10);
}
```
#### 类模板和函数模板的区别
1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

错误1：
```c++
template<class nametype, class agetype>
class Person
{

};

void test()
{
    Person p1("Zhang San", 10); // 错误,无法自动推导
    Person<string, int> p1("Zhang San", 10); // 正确
}
```
示例2：
```c++
template <class typename, class typeage = int /* 默认参数*/ >
class Person
{
public:
    typename m_name;
    typeage m_age;
};

void test()
{
    Person<string> p1("Zhang San", 10); // 正确
}
```
#### 类模板中成员函数创建时机
区别：
1. 普通类中的成员函数一开始就创建
2. 类模板中的成员函数在`调用时`才创建
#### 类模板对象做 函数参数
传入方式：
1. 指定传入的类型：最为常用
2. 参数模板化
3. 整个类模板化
```c++
// 1
void print_person1(Person<string, int>& p);

// 2
template<class T1, class T2>
void print_person2(Person<T1, T2>& p);

// 3
template<class T1, class T2>
void print_person2(Person<T1, T2>& p);
```
#### 类模板与继承
注意：
1. 当子类的父类是一个类模板时，子类声明时需要指明父类中`T`的类型
2. 如果不指定，编译器无法给子类分配内存
3. 如果想灵活使用父类中`T`的类型，子类也许变为类模板
#### 类模板成员函数类外实现
```c++
template<class T1, class T2>
class Person
{
public:
    Person(T1 name, T2 age);

    void show_info();
    
    T1 m_a;
    T2 m_b;
};

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
/* code  */
}

template<class T1, class T2>
void Person<T1, T2>::show_info()
{
    /* code */
}
```
#### 类模板分文件编写
问题：

类模板中成员函数创建时机是调用阶段，导致分文件编写链接不到

解决：
1. 直接包含`.cpp`
2. 将声明和实现写到同一个文件中，更改后缀名为`.hpp`,`.hpp`只是约定的名称，不强制要求
#### 类模板与友元
- 全局函数`类内`实现:直接类内声明友元
- 全局函数`类外`实现：需要提前让编译器知道全局函数的存在

建议：类内实现，类外实现麻烦
